## Reducing Coupling

When classes are built in a hierarchy, or mixins are distributed across a code base, coupling arises over time. Typically, as a code base evolves, each iteration of programmer uses whatever methods or properties have been made available by the accumulated efforts of previous iterations.

As time goes on, the number of methods and properties increases, and each new piece of behaviour touches more and moree methods and properties. WHen it comes time to refactor the code base, it can be very difficult to tease behaviour aprt, since so many pieces naturally end up depending on each other.

One way to resist this natural tendancy toward couplng is by making sure that each metaobject exposes only the methods it confers upon its receivers. All oter methods and properties should be kept private.

Note that making properties private is not an ideological issue: It's not a question of "purity in OO theory." It's a practical issue: It's a question of minimizing the surfqace area of the metaobject in order to minimize the ways in which it can become coupled to other objects.

### using symbols to reduce coupled properties

Consider `IsAuthor`, a mixin for `Person' (and any other class that might represent authors):

~~~~~~~~
const IsAuthor = {
  addBook (name) {
    this._books.push(name);
    return this;
  },
  books () {
    return this._books;
  }
};
~~~~~~~~

And consider `Bibliophile`, a mixin representing book collectors:

~~~~~~~~
const Bibliophile = {
  addBookToCollection (name) {
    this._books.push(name);
    return this;
  },
  collection () {
    return this._books;
  }
};
~~~~~~~~

Although there is no conflict between the methods both mixins provide, there is a conflict between their state: Both use the `_books` property. Note how the books Isaac Asimov has written and collects have become intermingled:

~~~~~~~~
const IsAuthor = (function () {
  const books = Symbol();
  
  return {
    addBook (name) {
      this.books().push(name);
      return this;
    },
    books () {
      return this[books] || this[books] = [];
    }
  };
})();

const Bibliophile = (function () {
  const books = Symbol();
  
  return {
    addBookToCollection (name) {
      this.collection().push(name);
      return this;
    },
    collection () {
      return this[books] || this[books] = [];
    }
  };
})();

Object.assign(Person.prototype, IsAuthor, Bibliophile);

new Person('Isaac', 'Asimov')
  .addBook('I Robot')
  .addBookToCollection('The Mysterious Affair at Styles')
  .collection()
    //=> ["I Robot","The Mysterious Affair at Styles"]
~~~~~~~~

We can correct this problem using symbols, as we saw with creating [privacy with symbols](#privacy-with-symbols) earlier:

~~~~~~~~
const IsAuthor = (function () {
  const books = Symbol();
  
  return {
    addBook (name) {
      this.books().push(name);
      return this;
    },
    books () {
      return this[books] || (this[books] = []);
    }
  };
})();

const Bibliophile = (function () {
  const books = Symbol();
  
  return {
    addBookToCollection (name) {
      this.collection().push(name);
      return this;
    },
    collection () {
      return this[books] || (this[books] = []);
    }
  };
})();

Object.assign(Person.prototype, IsAuthor, Bibliophile);

new Person('Isaac', 'Asimov')
  .addBook('I Robot')
  .addBookToCollection('The Mysterious Affair at Styles')
  .collection()
    //=> ["The Mysterious Affair at Styles"]
~~~~~~~~

The conflict is gone. Using techniques to keep mixin state private reduces conflicts between mixins, other mixins, classes, and other classes. This also reduces coupling as it discourages writing mxins or subclasses that rely on the private state of other mixins or classes.