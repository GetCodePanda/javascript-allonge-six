## Basic Operations on Iterables

Here are the operations we've defined on Iterables. As discussed, they preserve the collection semantics of the iterable they are given:

### operations that transform one iterable into another

{:lang="js"}
~~~~~~~~
function * mapIterableWith(fn, iterable) {
  for (const element of iterable) {
    yield fn(element);
  }
};

const mapAllIterableWith = (fn, iterable) =>
  ({
    [Symbol.iterator]: function* () {
      for (let element of iterable) {
        yield* fn(element);
      }
    }
  });

const filterIterableWith = (fn, iterable) =>
  ({
    [Symbol.iterator]: function* () {
      for (let element of iterable) {
        if (!!fn(element)) yield element;
      }
    }
  });

const compactIterable = (iterable) =>
  ({
    [Symbol.iterator]: function* () {
      for (let element of iterable) {
        if (element != null) yield element;
      }
    }
  });

const untilIterableWith = (fn, iterable) =>
  ({
    [Symbol.iterator]: function* () {
      for (let element of iterable) {
        if (fn(element)) break;
        yield fn(element);
      }
    }
  });

function * restOfIterable (iterable) {
  const iterator = iterable[Symbol.iterator]();

  iterator.next();
  return iterator;
}

function * take (numberToTake, iterable) {
  const iterator = iterable[Symbol.iterator]();

  for (let i = 0; i < numberToTake; ++i) {
    const { done, value } = iterator.next();
    if (!done) yield value;
  }
}
~~~~~~~~

### operations that compose two or more iterables into an iterable

{:lang="js"}
~~~~~~~~
function * zipIterables (...iterables) {
  const iterators = iterables.map(i => i[Symbol.iterator]());

  while (true) {
    const pairs = iterators.map(j => j.next()),
          dones = pairs.map(p => p.done),
          values = pairs.map(p => p.value);

    if (dones.indexOf(true) >= 0) break;
    yield values;
  }
};

function * zipIterablesWith (zipper, ...iterables) {
  const iterators = iterables.map(i => i[Symbol.iterator]());

  while (true) {
    const pairs = iterators.map(j => j.next()),
          dones = pairs.map(p => p.done),
          values = pairs.map(p => p.value);

    if (dones.indexOf(true) >= 0) break;
    yield zipper(...values);
  }
};
~~~~~~~~

Note: `zipIterables` is the following special case of `zipIterablesWith`:

{:lang="js"}
~~~~~~~~
const zipIterables = callFirst(zipIterablesWith, (...values) => values);
~~~~~~~~

### operations that transform an iterable into a value

{:lang="js"}
~~~~~~~~
const reduceIterableWith = (fn, seed, iterable) => {
    let accumulator = seed;

    for (let element of iterable) {
      accumulator = fn(accumulator, element);
    }
    return accumulator;
  };

const firstOfIterable = (iterable) =>
  iterable[Symbol.iterator]().next().value;
~~~~~~~~

### memoizing an iterable

{:lang="js"}
~~~~~~~~
function memoize (generator) {
  const memos = {},
        iterator = generator();

  return function * (...args) {
    const key = JSON.stringify(args);
    let i = 0;

    if (memos[key] == null) memos[key] = [];

    while (true) {
      if (i < memos[key].length) {
        yield memos[key][i++];
      }
      else {
        const { done, value } = iterator.next();

        if (done) {
          return;
        } else {
          yield memos[key][i++] = value;
        }
      }
    }
  }
}
~~~~~~~~
